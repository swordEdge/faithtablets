"use strict";!function(factory){"object"==typeof module&&module.exports?module.exports=factory:factory(Highcharts)}(function(Highcharts){var H,pick,each,grep,arrayMin,arrayMax,seriesType,pieProto;pick=(H=Highcharts).pick,each=H.each,grep=H.grep,arrayMin=H.arrayMin,arrayMax=H.arrayMax,seriesType=H.seriesType,pieProto=H.seriesTypes.pie.prototype,seriesType("variablepie","pie",{minPointSize:"10%",maxPointSize:"100%",zMin:undefined,zMax:undefined,sizeBy:"area",tooltip:{pointFormat:'<span style="color:{point.color}">\u25cf</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'}},{pointArrayMap:["y","z"],parallelArrays:["x","y","z"],redraw:function(){this.center=null,pieProto.redraw.call(this,arguments)},zValEval:function(zVal){return"number"==typeof zVal&&!isNaN(zVal)||null},calculateExtremes:function(){var zMin,zMax,series=this,chart=series.chart,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,seriesOptions=series.options,slicingRoom=2*(seriesOptions.slicedOffset||0),zData=series.zData,smallestSize=Math.min(plotWidth,plotHeight)-slicingRoom,extremes={},positions=series.center||series.getCenter();each(["minPointSize","maxPointSize"],function(prop){var length=seriesOptions[prop],isPercent=/%$/.test(length);length=parseInt(length,10),extremes[prop]=isPercent?smallestSize*length/100:2*length}),series.minPxSize=positions[3]+extremes.minPointSize,series.maxPxSize=Math.max(Math.min(positions[2],extremes.maxPointSize),positions[3]+extremes.minPointSize),zData.length&&(zMin=pick(seriesOptions.zMin,arrayMin(grep(zData,series.zValEval))),zMax=pick(seriesOptions.zMax,arrayMax(grep(zData,series.zValEval))),this.getRadii(zMin,zMax,series.minPxSize,series.maxPxSize))},getRadii:function(zMin,zMax,minSize,maxSize){for(var pos,value,radius,i=0,zData=this.zData,len=zData.length,radii=[],sizeByArea="radius"!==this.options.sizeBy,zRange=zMax-zMin;i<len;i++)radius=(value=this.zValEval(zData[i])?zData[i]:zMin)<=zMin?minSize/2:zMax<=value?maxSize/2:(pos=0<zRange?(value-zMin)/zRange:.5,sizeByArea&&(pos=Math.sqrt(pos)),Math.ceil(minSize+pos*(maxSize-minSize))/2),radii.push(radius);this.radii=radii},translate:function(positions){this.generatePoints();var finalConnectorOffset,start,end,angle,radiusX,radiusY,i,point,pointRadii,pointRadiusX,pointRadiusY,series=this,cumulative=0,precision=1e3,options=series.options,slicedOffset=options.slicedOffset,connectorOffset=slicedOffset+(options.borderWidth||0),startAngle=options.startAngle||0,startAngleRad=Math.PI/180*(startAngle-90),endAngleRad=Math.PI/180*(pick(options.endAngle,startAngle+360)-90),circ=endAngleRad-startAngleRad,points=series.points,labelDistance=options.dataLabels.distance,ignoreHiddenPoint=options.ignoreHiddenPoint,len=points.length;for(series.startAngleRad=startAngleRad,series.endAngleRad=endAngleRad,series.calculateExtremes(),positions||(series.center=positions=series.getCenter()),series.getX=function(y,left,point){var radii=point.series.radii[point.index];return angle=Math.asin(Math.min((y-positions[1])/(radii+point.labelDistance),1)),positions[0]+(left?-1:1)*(Math.cos(angle)*(radii+point.labelDistance))},i=0;i<len;i++)point=points[i],pointRadii=series.radii[i],point.labelDistance=pick(point.options.dataLabels&&point.options.dataLabels.distance,labelDistance),series.maxLabelDistance=Math.max(series.maxLabelDistance||0,point.labelDistance),start=startAngleRad+cumulative*circ,ignoreHiddenPoint&&!point.visible||(cumulative+=point.percentage/100),end=startAngleRad+cumulative*circ,point.shapeType="arc",point.shapeArgs={x:positions[0],y:positions[1],r:pointRadii,innerR:positions[3]/2,start:Math.round(start*precision)/precision,end:Math.round(end*precision)/precision},(angle=(end+start)/2)>1.5*Math.PI?angle-=2*Math.PI:angle<-Math.PI/2&&(angle+=2*Math.PI),point.slicedTranslation={translateX:Math.round(Math.cos(angle)*slicedOffset),translateY:Math.round(Math.sin(angle)*slicedOffset)},radiusX=Math.cos(angle)*positions[2]/2,radiusY=Math.sin(angle)*positions[2]/2,pointRadiusX=Math.cos(angle)*pointRadii,pointRadiusY=Math.sin(angle)*pointRadii,point.tooltipPos=[positions[0]+.7*radiusX,positions[1]+.7*radiusY],point.half=angle<-Math.PI/2||angle>Math.PI/2?1:0,point.angle=angle,finalConnectorOffset=Math.min(connectorOffset,point.labelDistance/5),point.labelPos=[positions[0]+pointRadiusX+Math.cos(angle)*point.labelDistance,positions[1]+pointRadiusY+Math.sin(angle)*point.labelDistance,positions[0]+pointRadiusX+Math.cos(angle)*finalConnectorOffset,positions[1]+pointRadiusY+Math.sin(angle)*finalConnectorOffset,positions[0]+pointRadiusX,positions[1]+pointRadiusY,point.labelDistance<0?"center":point.half?"right":"left",angle]}})});